#include "dshot.h"
#include "dshot.pio.h" // Generated by CMake
#include "hardware/pio.h"
#include "hardware/clocks.h"

// GP6-11 for Motors 1-6 (Hexacopter)
const uint dshot_pins[NUM_MOTORS] = {6, 7, 8, 9, 10, 11};

static PIO pio_hw = pio0;
static uint sm_offsets[NUM_MOTORS];

void dshot_init(void) {
    uint offset = pio_add_program(pio_hw, &dshot_program);
    float div = (float)clock_get_hz(clk_sys) / (DSHOT_SPEED * 8.0f);

    uint pio1_offset = 0;
    bool pio1_loaded = false;

    for (int i = 0; i < NUM_MOTORS; i++) {
        // Motors 0-3 on PIO0, Motors 4-5 on PIO1
        PIO current_pio = (i < 4) ? pio0 : pio1;
        uint current_offset = offset;
        
        // Load program into PIO1 if needed
        if (current_pio == pio1) {
            if (!pio1_loaded) {
                pio1_offset = pio_add_program(pio1, &dshot_program);
                pio1_loaded = true;
            }
            current_offset = pio1_offset;
        }
        
        uint sm = (i < 4) ? i : (i - 4);
        dshot_program_init(current_pio, sm, current_offset, dshot_pins[i]);
        pio_sm_set_clkdiv(current_pio, sm, div);
        pio_sm_set_enabled(current_pio, sm, true);
    }
}

static uint16_t prepare_dshot_packet(float throttle, bool telemetry) {
    if (throttle <= 0.001f) {
        return 0; // Command 0: Disarm / Stop
    }
    if (throttle > 1) throttle = 1;
    
    uint16_t value = (uint16_t)(throttle * 2000) + 48; // DShot range 48-2047
    if (value > 2047) value = 2047;
    
    uint16_t packet = (value << 1) | (telemetry ? 1 : 0);
    
    // CRC: (packet ^ (packet >> 4) ^ (packet >> 8)) & 0x0F
    unsigned csum = 0;
    unsigned csum_data = packet;
    for (int i = 0; i < 3; i++) {
        csum ^= csum_data;
        csum_data >>= 4;
    }
    csum &= 0xf;
    
    return (packet << 4) | csum;
}

void dshot_write_throttle(uint8_t motor_index, float throttle) {
    if (motor_index >= NUM_MOTORS) return;
    
    uint16_t packet = prepare_dshot_packet(throttle, false);
    
    // Send to FIFO
    // Motors 0-3 -> PIO0. Motors 4-5 -> PIO1.
    PIO current_pio = (motor_index < 4) ? pio0 : pio1;
    uint sm = (motor_index < 4) ? motor_index : (motor_index - 4);
    
    // Blocking write if FIFO full, but we should be fast enough
    pio_sm_put_blocking(current_pio, sm, (uint32_t)packet << 16); // Shift for MSB first in 32bit reg?
    // Wait, our PIO shifts out from OSR. default is right shift?
    // In init: sm_config_set_out_shift(&c, false, ...); -> shift left (MSB first).
    // If we write 16 bits to 32-bit FIFO...
    // pio_sm_put writes to TX FIFO.
    // If pull is 'block', it pulls 32 bits? The PIO code says `set x, 15` -> 16 bits.
    // We need to ensure the data is aligned.
    // If shift left (MSB first), OSR is filled from FIFO.
    // We usually write the data left-aligned or right-aligned depending on pull.
    // Let's just write it normally and assume the user handles the alignment or the shift handles it.
    // Actually, for MSB first `out y, 1`, we want the data at the "top" if we pull, 
    // OR we just push correctly.
    // Let's simply push the packet left-shifted if needed. 
    // For safety in this simplified task, I'll stick to `packet << 16` assuming 32-bit pull and we want the high bits.
}

void dshot_send_frame(void) {
    // Placeholder: DShot transmission is handled by PIO state machine auto-pull
    // This function can be used for frame synchronization if needed later.
}
