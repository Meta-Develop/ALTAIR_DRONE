; SPI Slave (CPHA=0, CPOL=0)
; 
; Pin assignments (configured in C):
; - OUT: MISO
; - IN:  MOSI
; - JMP: CS
; 
; Hardcoded GPIOs for Wait (can be patched or configured if using pin mapping carefully):
; But for simplicity in this project (fixed wiring), we will use hardcoded GPIOs in 'wait' instruction 
; or use relative 'pin' if we map Input to SCK? 
; Input is MOSI.
; We can't map multiple inputs easily for 'wait'.
; We will use hardcoded GPIO numbers for SCK (18) and CS (17) to be safe.

.program spi_slave

.wrap_target
    ; 1. Wait for CS (GP17) to go Low
    wait 0 gpio 17
    
    ; Signal IRQ for DMA re-arm (Replaces physical loopback)
    irq 0
    
    ; TEST: Hardcode OSR to All Ones (0xFFFFFFFF)
    ; This ignores TX FIFO and sends 1s.
    mov osr, ~null      
    
    ; ALIGNMENT FIX REMOVED (Not needed for all 1s)
    ; out null, 24

    ; Shift MSB (Bit 7) to MISO (GP19)
    out pins, 1

    ; 3. Bit loop for bits 0..6 (7 bits) + last bit handling
    ; Actually, simpler loop structure:
    set x, 6        ; Loop 7 times

bitloop:
    ; Wait for SCK (GP18) Rising Edge (Sample MOSI)
    wait 1 gpio 18
    in pins, 1      ; Sample MOSI (GP16) into ISR

    ; Wait for SCK Falling Edge (Shift MISO)
    wait 0 gpio 18
    out pins, 1     ; Shift next bit to MISO
    
    jmp x-- bitloop ; Repeat

    ; 4. Last Bit (Bit 7 of Input, Bit 0 of Output was shifted in loop? 
    ; Wait. 
    ; OUT: Bit 7 (Before Loop), Bits 6..1 (In Loop). 
    ; Loop runs 7 times.
    ; Iteration 0: Wait Rise, Sample IN(7), Wait Fall, Out(6).
    ; ...
    ; Iteration 6: Wait Rise, Sample IN(1), Wait Fall, Out(0).
    ; Done.
    ; We still need to Sample IN(0) on last Rise.
    
    wait 1 gpio 18
    in pins, 1      ; Sample MOSI (Bit 0)
    wait 0 gpio 18  ; Wait for idle (Fall)
    
    ; 5. Push received byte to RX FIFO
    push block
.wrap

% c-sdk {
#include "hardware/gpio.h"

static inline void spi_slave_init(PIO pio, uint sm, uint offset, uint pin_mosi, uint pin_cs, uint pin_sck, uint pin_miso) {
    // 1. Configure Pin Mappings
    // MISO is Output (Side Set? No, just OUT) -> OUT BASE
    // MOSI is Input -> IN BASE
    // CS and SCK are used by WAIT instructions (Hardcoded in PIO, but we init GPIOs here)
    
    pio_sm_config c = spi_slave_program_get_default_config(offset);
    
    // Set OUT pin (MISO)
    sm_config_set_out_pins(&c, pin_miso, 1);
    
    // Set IN pin (MOSI)
    sm_config_set_in_pins(&c, pin_mosi);
    
    // Set SIDESET? Not used.
    
    // Init GPIOs
    pio_gpio_init(pio, pin_mosi);
    pio_gpio_init(pio, pin_cs);
    pio_gpio_init(pio, pin_sck);
    pio_gpio_init(pio, pin_miso);
    
    // Directions
    // Input: MOSI, CS, SCK
    // Output: MISO
    pio_sm_set_consecutive_pindirs(pio, sm, pin_mosi, 1, false);
    pio_sm_set_consecutive_pindirs(pio, sm, pin_cs, 1, false);
    pio_sm_set_consecutive_pindirs(pio, sm, pin_sck, 1, false);
    pio_sm_set_consecutive_pindirs(pio, sm, pin_miso, 1, true);
    
    // Shifters
    // IN: Shift Right (LSB first)? SPI usually MSB First.
    // OUT: Shift Right (MSB first)? 
    // Shift Left = MSB First. Shift Right = LSB First.
    // SPI Standard: MSB First.
    // So shift LEFT, autopull/push off (we handle it).
    // Actually, 'in pins, 1' shifts into ISR. default is right/left?
    // Let's use standard MSB First: Shift Left.
    // In: Shift Left, Autopush OFF (we push manually).
    // Out: Shift Left, Autopull OFF (we pull manually).
    
    sm_config_set_in_shift(&c, false, false, 8);  // Left, No Autopush, 8 bits
    sm_config_set_out_shift(&c, false, false, 8); // Left, No Autopull, 8 bits
    
    // Initialize
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}
%}
